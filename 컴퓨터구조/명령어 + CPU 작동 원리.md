## 고급 언어와 저급 언어
### 고급 언어
- 개발자가 이해하기 쉽게 만든 언어

| __컴파일 언어__ | __인터프리터 언어__ |
| :---: | :---: |
| 컴파일러에 의해 저급 언어로 변환 | 인터프리터에 의해 한 줄씩 실행 |
| 소스 코드 컴파일 중 오류가 발생하면 소스 코드 전체가 실행되지 않음 | 소스 코드 인터프리트 중 오류가 발생하면 오류 발생 전까지의 코드는 실행 |

- 컴파일 결과로 저급 언어인 목적 코드(오브젝트 코드)가 생성됨


### 저급 언어
- 컴퓨터가 이해하고 실행하는 언어
- __기계어__
  - 0과 1로 이루어진 명령어
- __어셈블리어__
  - 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어 

<br>

## 명령어 구조
### 구조
- 연산 코드와 오퍼랜드로 이루어짐
  - __연산 코드__ : 수행할 연산
  - __오퍼랜드__ :연산에 사용될 데이터 혹은 연산에 사용될 데이터가 저장된 위치
  
### 오퍼랜드 
- 오퍼랜드 필드(주소 필드)
  - 오퍼랜드에는 연산에 저장될 데이터가 저장된 위치가 훨씬 자주 담기게 됨
  - 위치 값을 쓰는 이유 : 명령어 내에서 표현 가능한 데이터 크기가 제한되기 때문
- 오퍼랜드는 없을 수도 있고, 여러 개가 될 수 있음

### 연산 코드
- 종류
  1. 데이터 전송
  2. 산술/논리 연산
  3. 제어 흐름 변경
  4. 입출력 변경
- 데이터 전송
  - MOVE : 데이터를 옮겨라
  - STORE : 메모리에 저장하라
  - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
  - PUSH : 스택에 데이터를 저장하라
  - POP : 스택의 최상단 데이터를 가져와라
- 산술/논리 연산
  - ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈
  - INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 빼라
  - AND / OR / NOT
  - COMPARE : 두 개의 숫자 또는 TRUE/FALSE 값을 비교하라
- 제어 흐름 변경
  - JUMP : 특정 주소로 실행 순서를 옮겨라
  - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
  - HALT : 프로그램의 실행을 멈춰라
  - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
  - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
- 입출력 제어
  - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
  - WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
  - START IO : 입출력 장치를 시작하라
  - TEST IO : 입출력 장치의 상태를 확인하라

## 명령어 주소 지정 방식
### 유효 주소 (effective address)
- 연산에 사용할 데이터가 저장된 위치

### 명령어 주소 지정 방식 (addressing modes)
- 연산에 사용할 데이터가 저장된 위치를 찾는 방법
- 유효 주소를 찾는 방법

### 즉시 주조 지정 방식 (immediate addressing mode)
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
- 가장 간단한 형태
- 연산에 사용할 데이터의 크기는 작아지지만 빠름

### 직접 주소 지정 방식 (direct addressing mode)
- 오퍼랜드 필드에 유효 주소를 직접적으로 명시
- 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦

### 간접 주소 지정 방식 (indirect addressing mode)
- 오퍼랜드 필드에 유효 주소의 주소를 명시
- 다른 방식에 비해 속도가 느림

### 레지스터 주소 지정 방식 (register addressing mode)
- 연산에 사용할 데이터가 저장된 레지스터 명시
- CPU의 메모리 접근 속도 < CPU의 레지스터 접근 속도

### 레지스터 간접 주소 지정 방식 (register indirect addressing mode)
- 연산에 사용할 데이터를 메모리에 저장
- 주소를 저장한 레지스터를 오퍼랜드 필드에 명시

<br>

## C언어 컴파일 과정
### 과정
- 전처리기(preprocessor) -> 컴파일러(compiler) -> 어셈블러(assembler) -> 링커(linker)

### 전처리 과정 (preprocessing)
- 본격적으로 컴파일하기 전 처리할 작업들
- 외부에 선언된 다양한 소스 코드, 라이브러리 포함 (#include)
- 프로그래밍 편의를 위해 작성된 매크로 변환 (#define)
- 컴파일할 영역 명시 (#if, #ifdef...)

### 컴파일 과정 (compiling)
- 전처리가 완료 되어도 여전히 소스 코드
- 전처리가 완료된 소스 코드를 저급 언어(어셈블리 언어)로 변환

### 어셈블 과정 (assembling)
- 어셈블리어를 기계어로 변환
- 목적 코드(object file)를 포함하는 목적 파일이 됨
- 목적 파일 vs 실행 파일
  - 둘 다 기계어로 이루어진 파일
  - 목적 파일은 링킹(linking)을 거친 이후에 실행 파일이 됨

### 링킹 (linking)
- 각기 다른 목적 코드를 하나의 실행 파일로 묶어주는 작업
- 실행 파일이 만들어짐

<br><br>

## ALU
### 개념
- 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호를 받아들임
- CPU 내부의 계산을 위한 회로
- 결과값을 레지스터에 담아 내보냄
  - 레지스터에 담는 이유 : CPU 접근 속도가 빠르기 때문
- __플래그__ : 연산 결과에 대한 부가 정보
  - 플래그 값은 플래그 레지스터에 저장
  - 연산 결과가 결과를 담을 레지스터에 비해 너무 크면 오버플로우 발생 -> 플래그에 명시
  
  | 종류 | 의미 |
  | :---: | :---: |
  | 부호 플래그 | 연산한 결과의 부호를 나타냄(0은 양수, 1은 음수) |
  | 제로 플래그 | 연산 결과가 0인지를 나타냄(1이면 결과 0, 0이면 결과 0이 아님) |
  | 캐리 플래그 | 연산 결과 올림수나 빌림수가 발생했는지 나타냄 |
  | 오버플로우 플래그 | 오버플로우 발생 여부를 나타냄 |
  | 인터럽트 플래그 | 인터럽트 가능 여부를 나타냄 |
  | 슈퍼바이저 플래그 | 커널 모드인지 사용자 모드인지 나타냄(0은 사용자, 1은 커널) |
 
 
### 제어장치
- __클럭 신호__ : 컴퓨터의 모든 부품들을 움직일 수 있게 하는 시간 단위
  - 클럭 신호 단위에 맞춰서 명령어들이 실행됨
- 플래그 : 명령 연산에 필요함
- 외부로부터 제어 신호가 들어오면 CPU가 어떤 신호인지 제어 장치가 

<br>

## 레지스터
### 정의
- CPU 내부의 작은 임시 저장 장치
- 프로그램 속 명령어와 데이터는 실행 전후로 레지스터에 저장

### 종류
- __프로그램 카운터__ : 메모리에서 가져올 명령어의 주소 (메모리에서 읽어 들일 명령어의 주소)
- __명령어 레지스터__ : 해석할 명령어 (방금 메모리에서 읽어 들인 명령어)
- __메모리 주소 레지스터__ : 메모리의 주소 (CPU가 읽어들이고자 하는 주소를 주소 버스로 보낼 때 거치는 레지스터)
- __메모리 버퍼 레지스터__ : 메모리와 주고받을 값(데이터와 명령어)
- __플래그 레지스터__ : 연산 결과 또는 CPU 상태에 대한 부가적인 정보
- __범용 레지스터__ : 다양하고 일반적인 상황에서 자유롭게 사용
- __스택 포인터__ : 스택의 꼭대기를 가리킴
- __베이스 레지스터__ : 베이스 레지스터 주소 지정 방식의 기준 주소 저장

### 명령어 실행 과정
1. CPU 프로그램 카운터에 1000(주소 값)이 담김
-> 다음에 1000번지의 명령어를 실행하겠다는 말
2. 메모리 주소 레지스터에 읽고자 하는 주소 1000을 복사
3. 제어장치에서 보낸 메모리 읽기 신호와 함께 주소 버스로 1000번지 주소를 메모리로 보냄 
4. 메모리는 1000번지에 저장된 값을 데이터 버스를 통해 메모리 버퍼 레지스터로 보내줌
5. 프로그램 카운터 값을 1001로 증가
6. 메모리 버퍼 레지스터에 담긴 값을 명령어 레지스터에 복사
- 순차적인 실행 흐름이 끊기는 경우
  - 특정 메모리 주소로 실행 흐름을 이동하는 명령어 실행 시
  (JUMP, CONDITIONAL JUMP, CALL, RET)
  - 인터럽트 발생 시

### 특정 레지스터를 이용한 주소 지정 방식
- __스택 주소 지정 방식__ : 스택과 스택 포인터를 이용한 주소 지정 방식
  - 스택 포인터 : 스택의 꼭대기를 가리키는 레지스터
- __변위 주소 지정 방식__ : 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻는 방식
  - 변위 주소 지정을 사용하는 명령어는 연산 코드(명령의 내용), 레지스터(값을 더할 레지스터 지정), 오퍼랜드(주소 값)을 포함
  - __상대 주소 지정 방식__ : 오퍼랜드 필드 값 + PC 값
  - __베이스 레지스터 주소 지정 방식__ : 오퍼랜드 필드 값 + 베이스 레지스터
  
<br><br>

## 명령어 사이클
### 정의
- 프로그램 속 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 명령어 사이클이라고 함

### 종류
- 인출 사이클 : 메모리에 저장된 값을 CPU 내부로 가져오는 작업의 주기
- 실행 사이클 : 명령어를 실행하는 주기
- 간접 사이클 : 인출 후 메모리 접근이 추가로 필요한 경우
  - 인출을 해도 바로 실행이 불가능할 수 있음 (간접 주소 지정 방식)
- 보통 인출-실행의 반복
- 인터럽트 사이클 : 인터럽트가 발생했을 때

## 인터럽트(interrupt)
### 정의
- CPU의 명령어 흐름을 방해하는 신호
- CPU가 바로 처리해야 하는 다른 작업이 생겼을 때 발생

### 종류
- __동기 인터럽트(예외)__ : CPU가 예기치 못한 상황을 접했을 때 발생
  - 주소에 접근했는데 값이 없을 때, 디버깅, 0으로 나누기, 실행할 수 없는 명령어 등
  - 종류 : 폴트, 트랩, 중단, 소프트웨어 인터럽트
- __비동기 인터럽트(하드웨어 인터럽트)__ : 주로 입출력 장치에 의해 발생
  - 막을 수 있는 인터럽트(maskable interrupt)
  - 막을 수 없는 인터럽트(non maskable interrupt)
  
### 하드웨어 인터럽트
- 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 사용
- 입출력 장치는 CPU에 비해 느림
- 인터럽트가 없다면 CPU는 프린트 완료 여부를 주기적으로 확인해야 함
- 인터럽트가 있다면 입출력 작업 동안 CPU가 다른 작업을 할 수 있음

### 하드웨어 인터럽트 처리 순서
1. 입출력 장치는 CPU에 __인터럽트 요청 신호__를 보냄
2. CPU는 실행 사이클이 끝나고 명령어 인출 전에 인터럽트 여부 확인
   - 플래그 레지스터 속 인터럽트 플래그를 확인
3. CPU는 인터럽트 요청을 확인하고 __인터럽트 플래그__를 통해 현재 인터럽트를 받아들일 수 있는지 확인
   - 모든 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아님 
   (대부분의 입출력 장치가 보내는 인터럽트는 웬만하면 막을 수 있음)
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
5. CPU는 __인터럽트 벡터__를 참조해 __인터럽트 서비스 루틴__을 실행
   - 인터럽트 서비스 루틴 : 인터럽트 발생 시 해당 인터럽트를 처리하기 위한 프로그램
     - 인터럽트 서비스 루틴도 메모리에 저장됨
     - 인터럽트를 보내는 주체에 따라 각기 다른 인터럽트 서비스 루틴의 시작 주소를 가짐
   - 인터럽트 벡터 : 각각 인터럽트 정보를 구분하기 위한 정보
     - 인터럽트의 시작 주소는 인터럽트 벡터를 통해 알 수 있음
     - 보통 인터럽트를 보내는 주체는 인터럽트와 함께 인터럽트 벡터를 데이터 버스를 통해 보냄
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업한 작업을 복구해 실행 재개
   - 인터럽트 발생 전 작업하던 내용은 스택에 백업